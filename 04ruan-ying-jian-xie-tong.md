# 04 软硬件协同
### 应用程序二进制接口ABI
ABI定义了应用程序二进制代码中数据结构和函数模块的格式及其访问方法
> API：应用程序**编程**接口
> ABI：应用程序**二进制**接口

* **寄存器约定**：约定通用寄存器的使用方法、别名等
* **函数调用约定**：约定参数如何传递给被调用的函数、结果如何返回、函数栈帧如何组织等
    * 整数调用规范
    * 硬件浮点调用规范
* **进程虚地址空间**：虚拟存储管理为每个进程提供了一个独立的虚拟地址空间，指令系统、操作系统、工具链和应用程序会互相配合对其进行管理
    * 应用程序的代码（来自应用程序的二进制文件）、初始化数据和未初始化数据
    * 堆（下->上）
    * 函数库的代码、初始化数据和未初始化数据
    * 栈（上->下）
* **栈帧布局**

    栈：大小可动态调整。被组织成一个个栈帧（一段连续的内存地址空间），每个函数都可以有自己的栈帧。
    最完整情况：同时利用$sp（指向栈顶）和$fp（指向当前函数的栈帧开始处）两个寄存器来维护栈帧。编译器为函数在入口处生成一个函数头，返回处生成一个函数尾，它们负责调整$sp和$fp寄存器以生成新的栈帧或者释放一个栈帧，并生成必要的寄存器保存和恢复代码

### 六种常见的上下文切换场景
* **函数调用**：用户主动发起的指令流和上下文改变
    * **部分寄存器（包括栈帧相关的$sp和$fp）、返回地址**
* **系统调用**：操作系统内核为用户态程序实现的子程序
    * 和普通调用相比主要多了特权等级的切换
    * **部分定点寄存器（包括栈帧相关寄存器）、异常现场信息**
* **例外处理**（异常和中断）
    * 通常栈指针也会被重新设置为指向内核态代码所使用的栈，以便隔离不同特权等级代码的运行信息
    * **（通常情况）全部定点寄存器、异常现场信息、异常相关信息**
* **线程切换**：操作系统内核管理或用户态线程管理或两者混合
    * 共享内存，因此内存不变
    * 共享打开文件
    * 逻辑上拥有独立的的寄存器状态和栈
    * **全部用户态寄存器、TLS、当前PC等相关信息**
* **进程切换**：主要由软件完成
    * 进程上下文包括进程控制块记录的各种信息（每个进程运行过程中虚拟内存地址、打开文件、锁和信号等资源的情况）
    * 要切内存内容
    * **全部用户态寄存器、页表基址等控制寄存器、当前PC等相关信息**
* **虚拟机切换**：虚拟机可以完全由软件实现
    * 上下文包括CPU、内存和外设状态
    * 核心态要变
    * **虚拟CPU状态（寄存器、必要特权资源）**

前三者保留现场因情况而异；后三个切换后需要保留比较完整的现场

### 同步与通讯
用LL/SC指令实现锁机制（对复杂操作不适合）
* LL指令设置LL bit，并检测访问的物理地址是否被修改或可能被修改，在检测到时将LL bit清除
* SC指令实现带条件的存储。当LL bit为0时，SC不会完成存储操作，而是把保存值的源操作数寄存器清零以示失败
    
测试并设置：取回锁的旧值并设置新的锁值
```
    la.local    $t1, lock
test_and_set:
    ll.w        $t0, $t1, 0
    li          $t0, 0x1
    sc.w        $t0, $t1, 0
    beqz        $t0, test_and_set
```
自旋锁：反复自旋得到锁后再进入临界区
```
    la.local    $a0, lock
selfspin:
    ll.w        $t0, $a0, 0
    beqz        $t0, selfspin
    li          $t1, $0x1
    sc.w        $t1, $a0, 0
    beqz        $t1, selfspin
    <Critical section>
    st.w        $zero, lock
```