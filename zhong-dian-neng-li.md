# 需要掌握的重点能力
### 掌握从键盘操作到显示变化的整体软硬件过程
* 如：PPT翻页过程
    * 按一下键盘，键盘会产生一个信号送到南桥芯片，南桥芯片把键盘的编码保存在南桥内部的一个寄存器中，并向处理器发出一个外部中断信号。该外部中断信号传到 CPU内部后把CPU中一个控制寄存器的某一位置为“1”，表示收到了外部中断。CPU 中另外一个控制寄存器有屏蔽位来确定是否处理这个外部中断信号。
    * 屏蔽处理后的中断信号被附在一条译码后的指令上送到重排序缓冲 (ROB)。外部中断是例外 (Exception，也称“异常”) 的一种，发生例外的指令不会被送到功能部件执行。当这条指令成为重排序缓冲的第一条指令时 CPU 处理例外。重排序缓冲为了给操作系统一个精确的例外现场，处理例外前要把例外指令前面的指令都执行完，后面的指令都取消掉。
    * 重排序缓冲向所有的模块发出一个取消信号，取消该指令后面的所有指令：修改控制寄在器，把系统状态设为核心态；保存例外原因、发生例外的程序计数器 (Program Counter，简称PC) 等到指定的控制寄存器中：然后把程序计数器的值置为相应的例外处理入口地址进行取指。
    * 处理器跳转到相应的例外处理器入口后执行操作系统代码，操作系统首先保存处理器现场，包括寄存器内容等。保存现场后，操作系统向 CPU 的控制寄存器读例外原因，发现是外部中断例外，就向南桥的中断控制器读中断原因，读的同时清除南桥的中断位。读回来后发现中断原因是有人敲了空格键。操作系统接下来要查找读到的空格是给谁的:有没有进程处在阻塞状态等键盘输入。大家都学过操作系统的进程调度，知道进程至少有三个状态一一运行态、阻塞态、就绪态，进程在等IO输人时处在阻塞态。操作系统发现有一个名为 WPS 的进程处于阻塞态，这个进程对空格键会有所响应，就把 WPS 唤醒。
    * WPS 被唤醒后处在运行状态。发现操作系统传过来的数据是个键盘输入空格，表示要翻页。WPS 就把下一页要显示的内容准备好，调用操作系统中的显示驱动程序，把要显示的内容送到显存，由图形处理器 (GPU) 通过访问显存空间刷新屏幕，达到了翻一页的效果。
    
    > 等待按键——中断处理（核心态）——准备数据——操作显存（核心态）——返回PPT

### 掌握基于LoongArch处理器的Linux操作系统TLB例外过程
* 指出一段程序共产生多少次TLB refi1和TLB invalid异常（可能包含TLB替换和进程切换）
![](/pic/TLBQ.png)
![](/pic/TLBA.png)

### C语言与指令系统的关系
* C语言的不同变量（全局、局部等）映射到地址空间的哪些段？
    1. 内存栈区： 存放局部变量名；
    2. 内存堆区： 存放new或者malloc出来的对象；
    3. 常数区： 存放局部变量或者全局变量的值；
    4. 静态区： 用于存放全局变量或者静态变量；
    5. 代码区：二进制代码
* 函数调用、系统调用、中断处理、进程切换都需要上下文切换，请结合LoongArch的ABI说明上述上下文切换时保留现场有什么不同（内容、位置）？
    * **函数调用**：用户主动发起的指令流和上下文改变
        * **部分寄存器（包括栈帧相关的$sp和$fp）、返回地址**
    * **系统调用**：操作系统内核为用户态程序实现的子程序
        * 和普通调用相比主要多了特权等级的切换
        * **部分定点寄存器（包括栈帧相关寄存器）、异常现场信息**
    * **例外处理**（异常和中断）
        * 通常栈指针也会被重新设置为指向内核态代码所使用的栈，以便隔离不同特权等级代码的运行信息
        * **（通常情况）全部定点寄存器、异常现场信息、异常相关信息**
    * **线程切换**：操作系统内核管理或用户态线程管理或两者混合
        * 共享内存，因此内存不变
        * 共享打开文件
        * 逻辑上拥有独立的的寄存器状态和栈
        * **全部用户态寄存器、TLS、当前PC等相关信息**
    * **进程切换**：主要由软件完成
        * 进程上下文包括进程控制块记录的各种信息（每个进程运行过程中虚拟内存地址、打开文件、锁和信号等资源的情况）
        * 要切内存内容
        * **全部用户态寄存器、页表基址等控制寄存器、当前PC等相关信息**
    * **虚拟机切换**：虚拟机可以完全由软件实现
        * 上下文包括CPU、内存和外设状态
        * 核心态要变
        * **虚拟CPU状态（寄存器、必要特权资源）**

前三者保留现场因情况而异；后三个切换后需要保留比较完整的现场

### 系统初始化时PCI设备的探测
* 如系统中有关IO设备是如何探测到的
> * PCI设备的探测：一个递归调用的过程
    1. 将初始总线号、初始设备号、初始功能号设为0
    2. 使用当前的总线号、设备号、功能号组成一个配置空间地址，使用该地址，访问其0号寄存器，检查其设备号。
    3. 如果读出全1或全0，表示无设备
    4. 如果该设备为有效设备，检查每个 BAR 所需的空间大小，并收集相关信息
    5. 检测其是否为一个多功能设备，如果是则将功能号加1再重复扫描，执行第2步
    6. 如果该设备为桥设备，则给该桥配置一个新的总线号，再使用该总线号，从设备号0、功能号0开始递归调用，执行第2步。
    7. 如果设备号非31，则设备号加1，继续执行第2步；如果设备号为31，且总线号为0，表示扫描结束，如果总线号非0，则退回上一层递归调用

### IO通信时DMA传输过程
* 如简单描述从硬盘读一个文件的DMA过程
    * 将数据写入磁盘的流程
        1. 用户程序将数据写入用户空间的缓冲区，然后调用write系统调用。
        2. CPU进入内核态，将数据写入拷贝到页缓存,写入成功，立即返回。
        3. 用户进程调用系统调用fsync、fdatasync、sync等刷盘指令。CPU会向DMA控制器发送写指令，告诉磁盘控制器要刷盘的数据在主存的位置、要刷盘多少数据、要刷到磁盘什么位置等，然后CPU就可以返回干其他事情了。
        4. DMA控制器开始将页缓存中的数据写入到磁盘。
        5. 写完了之后，DMA控制器会向CPU发出中断请求，触发中断处理程序，进行一些扫尾的工作。
    * 磁盘读取数据的流程
        1. 用户程序调用read系统调用。
        2. CPU进入内核态，操作系统会检查页缓存是否有数据。如果有CPU拷贝这些数据到用户空间；如果没有则触发缺页中断，需要向磁盘调页,即从磁盘加载数据到页缓存。
        3. CPU向DMA控制器发送读指令，并且告诉磁盘主存地址、要读取的数据长度、要从哪一个设备读，然后CPU返回干其他事情了。
        4. DMA控制器将磁盘中的数据拷贝到页缓存。
        5. 数据拷贝完成后，DMA控制器向CPU发送中断信号，触发中断处理程序，进行扫尾工作。
        6. 页缓存把数据返回给用户进程。
        
> * DMA方式：直接存储器访问
    * 在储器和外设之间开辟直接的数据传送通道，数据传送由专门的硬件（DMA控制器）来控制
    * 处理器为DMA请求预先分配一段地址空间
    * 处理器设置DMA控制器参数
    * DMA控制器进行数据传输
    * DMA控制器向处理器发出一个中断，通知处理器数据传送的结果
    * 处理器完成本次DMA请求，可以开始新的DMA请求


### 内存总线接口
* 给定一段DRAM总线波形图，给出DRAM访问的读写地址(要求熟悉DRAM总线各信号)

### AXI总线接口
* 用Verilog写出AXI接口的RAM（给出AXI关键信号）
![](/pic/AXIQA.png)

### 计算机中数据格式
* 定点补码、原码格式
* 浮点格式
![](/pic/IEEEQA.png)
    
### 读懂CMOS电路
* 给出一个晶体管电路，给出真值表和等价的逻辑表达式
![](/pic/CMOSQA.png)

### 先行进位加法器
* 用Verilog写出指定位数的先行进位加法器，或画指定位数的加法器的结构，并给出最长延迟(门的级数)
![](/pic/先行进位QA.png)

### 定点补码乘法器: Booth编码和华莱士树
* 给出指定个数相加的华莱士树的最小层数、利用半加器能增加多少进位(不改动全加器和改动全加器)
![](/pic/华莱士树.png)
![](/pic/华莱士树2.png)

### 指令流水线
* 给出一段程序，要求画出五级静态流水线时空图(可要求指出阻塞原因)，引入前递、提前计算跳转地址等机制后的流水线时空图

### 转移猜测
* 结合转移猜测算法，计算一段小程序的命中率
![](/pic/BHTQ.png)
![](/pic/BHTA1.png)
![](/pic/BHTA2.png)
![](/pic/BHTA3.png)

### Cache结构
* 访存地址中Tag、index、offset与Cache结构的对应关系
![](/pic/CacheQ.png)
![](/pic/CacheA.png)

### Pthread、OpenMP、MPI的基本思想，Amdahl定律
* 结合Amdahl定律，计算一段OpenMP程序的加速比

### 原子指令、同步操作、自旋锁
* 利用LL/SC指令实现锁
![](/pic/LL-SCQA.png)

### Cache一致性协议
* 目录写无效协议中，多核处理器访问共享变量的Cache一致性行为
![](/pic/ESI1.png)
![](/pic/ESI2.png)
![](/pic/ESI3.png)

### 性能比较分析
* 计算不同计算机的MIPS和IPC，并比较不同计算机的性能
* 了解perf的简单使用
* 分析EEMBC和SPEC CPU2000行为特性上有什么差别?